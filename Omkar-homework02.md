Homework-02 No Silver Bullet

Q1] Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.
Ans] Essential difficulties imply the difficulties that are inherent in the nature of software. According to the author it can be seen through the nature of the software that there will be no such inventions drastically evolving the software basics like productivity, reliability and simplicity. As the computer hardware has seen six orders of development in terms of magnitude in performance price gain in 30 years, it is essentially difficult for the software to follow on the similar footsteps. The author explains that it is not an inconsistency in software progress about its slow progress, but the computer hardware technology has evolved at a much faster pace as compared to software. For example, currently used Modern Integrated chips called System-on-Chips are used to perform the entire functionality of a computer device which required huge computer systems in the olden days. Another example would be the evolution of microcontrollers from 8048 or 8051 8-bit microcontrollers to ATmega328 and ESP8266 microcontrollers. These examples give us an idea of how powerful and technologically advanced computer hardware is today. As mentioned by the author the essence of software involves concepts involving algorithms for problems, datasets inheriting different data types, relationship among data items and invocations of functions. Similarly, for software, a prime example of essential difficulty would be software development using Agile Methodology. Agile involves fast paced development of technology in sprints. However, the sprints would involve design, development, and testing of software after which the deployment progresses, which indirectly explains why there is no single method to solve problems and why there is no silver bullet.

Q2] Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.   
Ans] Accidental difficulties involve the difficulties that are not inherent in software but attend to its production. These difficulties are focused towards the problems arising in building software which are accidental in nature. These difficulties negatively hamper the software productivity, reliability and simplicity. In terms of computer systems, as they are improved further, it has the possibility to cause fewer accidental difficulties in software production. The author argues that these difficulties were solved by past breakthroughs in terms of high-level compiling, time-sharing and unified programming environments. For example, a complex language like Assembly can be replaced by a higher-level language that is intuitive as a high-level language eliminates accidental complexity. Another example that could be considered for accidental difficulty is version control as version control across different platforms can cause major confusion and issues, if not tracked properly, and can disrupt operations in software production. 



Q3] List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.
Ans] a) Complexity: 
Essential property of a software is complexity. Author argues that digital computers themselves are more complex as they include many states and software systems as compared to these are significantly more complex as they have several magnitudes of more states. Software systems are inherently complex and systems that are non-complex basically lose their essence. As per the author, software development involves two main problems, its essential complexity and non-linear increase with size. The more the complexity, greater the problems that arise in teams while software development. Complexity can evolve to become the source of many technical and non-technical problems. Developing mobile or web applications can be considered an example of complexity. For development, usage of multiple languages like JavaScript, HTML, CSS, then source control, automation tools used for testing and building scripts while developing scalable applications can lead to high-level complexity and if not maintained and tracked properly will result in high costs for building the application.

b) Conformity:
 Conformity is adherence of software to the existing constraints. Software must comply with the expectations that are pre-defined. The author argues that complexity arises due to conformity of the software to the arbitrary environment that may change from interface to interface. A designer must adhere to external factors like data formats, pre-existing hardware, third-party components which may lead indirectly in increase in complexity. For example, a database manipulation problem may involve using MySQL to process data, a software program must be developed using Java version 13 or above or testing of a software component must involve regression testing and must satisfy required technical specifications and pre-defined guidelines.

c) Changeability:
Changeability is software that is subject to change. Author argues that most of the manufactured things are very rarely subject to change as they are either discarded and replaced by a better version or changes are made in the basic design itself in the later stages. Software undergoes change as it can be manipulated much more easily. Software undergoes changes in two processes, firstly when people use it and it is successful, people expect more features and functionality as they invent new uses for it, secondly as software survives the hardware it is meant to be served, it is expected to be changed for either better or newer versions of the hardware. For example, using Pythonâ€™s Seaborn library for plotting instead of Matplotlib for better visualization or using modern frameworks like Flash and JavaScript instead of Java Applets for web application development.

d) Invisibility:
Software is considered invisible as it has no representation in reality. As per the author, a building floor plan gives the Architect and the Owner a brief overview of the building, similarly, ICs have diagrams, land has maps, however, software is not visualizable. Author explains that drawing graphs that involve flow of data, time sequence or name-space relationships for software is not viable as the graphs are usually not planar and are superimposed which makes it difficult to visualize. Since the structure of software is unvisualizable, it hinders our mind to visualize the structure of the software which blocks the thought process of design and increases complexity. Abstractions in Java Object Oriented programming can be an example of invisibility or an internal working of a compiler or a class.

Q4] Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering. In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.
Ans] As per Brooks, there is no simple method or a single implementation that leads to increase in productivity, reliability or simplicity in software development. He explains this analogy by mentioning that computer hardware has evolved multiple folds from an assembly industry into a process industry, however, software progress is slow, which is primarily due to two factors, essence and accidents. Essence focuses on inherent problems in software that cause complexity, conformity, changeability, and invisibility denying the fast-paced progress for software while accidents are not inherent but attend software production causing difficulty in production. The author argues that software implementation is hard as it involves building software specification, design and testing of construct and there is no silver bullet to complete these processes. Software Engineering mainly focuses on the practical aspects of building software that involves creating high-quality, maintainable and reliable software while applying principles of computer science, design and engineering. A software engineer is similar to that of a chemical engineer as both apply knowledge of the fundamental principles of software and chemistry to develop and operate applications. Computer Science focuses on both the theoretical and practical aspects of software. It is similar to that of a chemist as a chemist focuses on the theoretical principles of chemistry, computer science focuses on the principles of computers and computational systems.

Q5] In the lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.
Ans] a) Abstraction:
Software Engineers break problems into something that is comprehensible by developing abstractions. Abstractions are typically used to simplify the development process by breaking it into parts such that they make sense. Regex can be used to implement abstractions.  
 b) Conversations:
Conversation involves communicating with the user, domain expert, developers to discuss software related abstractions. Conversations can involve discussions between users and domain experts to understand problem solving, with developers regarding documentation, design conversations to understand which abstraction to write, or to discuss test cases to see if the abstractions are working or not.
c) Specification:
Software Engineers typically require specification for development. This involves multiple aspects as they need a set of requirements which can be converted to stories as a placeholder for conversation. Similarly, design maps, test plans are required to be specified to define a roadmap for the future events and to understand the development cycles.
d) Translation:
Translation is essentially accumulating the specifications and converting them into software. Software engineering involves the translation of one specification to another, from one level of abstraction to another or from one specification to another.
e) Iteration:
Work is done in software engineering in iterations. Typically, two to three weeks of iterations take place which involves development of software. Iteration allows software to evolve and make sure that the final product is of high quality. 
      
